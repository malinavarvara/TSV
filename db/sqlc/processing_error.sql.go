// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: processing_error.sql

package db

import (
	"context"
	"database/sql"
)

const createProcessingError = `-- name: CreateProcessingError :one
INSERT INTO processing_errors (
    file_id,
    line_number,
    raw_line,
    error_message,
    field_name
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, file_id, line_number, raw_line, error_message, field_name, created_at
`

type CreateProcessingErrorParams struct {
	FileID       int64          `json:"file_id"`
	LineNumber   sql.NullInt32  `json:"line_number"`
	RawLine      sql.NullString `json:"raw_line"`
	ErrorMessage string         `json:"error_message"`
	FieldName    sql.NullString `json:"field_name"`
}

func (q *Queries) CreateProcessingError(ctx context.Context, arg CreateProcessingErrorParams) (ProcessingError, error) {
	row := q.db.QueryRowContext(ctx, createProcessingError,
		arg.FileID,
		arg.LineNumber,
		arg.RawLine,
		arg.ErrorMessage,
		arg.FieldName,
	)
	var i ProcessingError
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.LineNumber,
		&i.RawLine,
		&i.ErrorMessage,
		&i.FieldName,
		&i.CreatedAt,
	)
	return i, err
}

const deleteProcessingError = `-- name: DeleteProcessingError :exec
DELETE FROM processing_errors
WHERE id = $1
`

func (q *Queries) DeleteProcessingError(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteProcessingError, id)
	return err
}

const deleteProcessingErrorsByFile = `-- name: DeleteProcessingErrorsByFile :exec
DELETE FROM processing_errors
WHERE file_id = $1
`

func (q *Queries) DeleteProcessingErrorsByFile(ctx context.Context, fileID int64) error {
	_, err := q.db.ExecContext(ctx, deleteProcessingErrorsByFile, fileID)
	return err
}

const getProcessingErrorByID = `-- name: GetProcessingErrorByID :one
SELECT id, file_id, line_number, raw_line, error_message, field_name, created_at FROM processing_errors
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProcessingErrorByID(ctx context.Context, id int64) (ProcessingError, error) {
	row := q.db.QueryRowContext(ctx, getProcessingErrorByID, id)
	var i ProcessingError
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.LineNumber,
		&i.RawLine,
		&i.ErrorMessage,
		&i.FieldName,
		&i.CreatedAt,
	)
	return i, err
}

const listProcessingErrorsByFile = `-- name: ListProcessingErrorsByFile :many
SELECT id, file_id, line_number, raw_line, error_message, field_name, created_at FROM processing_errors
WHERE file_id = $1
ORDER BY line_number
`

func (q *Queries) ListProcessingErrorsByFile(ctx context.Context, fileID int64) ([]ProcessingError, error) {
	rows, err := q.db.QueryContext(ctx, listProcessingErrorsByFile, fileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProcessingError
	for rows.Next() {
		var i ProcessingError
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.LineNumber,
			&i.RawLine,
			&i.ErrorMessage,
			&i.FieldName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProcessingErrorsSummary = `-- name: ListProcessingErrorsSummary :many
SELECT
    error_message,
    field_name,
    COUNT(*) as error_count,
    MIN(line_number) as first_line,
    MAX(line_number) as last_line
FROM processing_errors
WHERE file_id = $1
GROUP BY error_message, field_name
ORDER BY error_count DESC
`

type ListProcessingErrorsSummaryRow struct {
	ErrorMessage string         `json:"error_message"`
	FieldName    sql.NullString `json:"field_name"`
	ErrorCount   int64          `json:"error_count"`
	FirstLine    interface{}    `json:"first_line"`
	LastLine     interface{}    `json:"last_line"`
}

func (q *Queries) ListProcessingErrorsSummary(ctx context.Context, fileID int64) ([]ListProcessingErrorsSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, listProcessingErrorsSummary, fileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProcessingErrorsSummaryRow
	for rows.Next() {
		var i ListProcessingErrorsSummaryRow
		if err := rows.Scan(
			&i.ErrorMessage,
			&i.FieldName,
			&i.ErrorCount,
			&i.FirstLine,
			&i.LastLine,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProcessingError = `-- name: UpdateProcessingError :one
UPDATE processing_errors
SET
    error_message = $2,
    field_name = $3
WHERE id = $1
RETURNING id, file_id, line_number, raw_line, error_message, field_name, created_at
`

type UpdateProcessingErrorParams struct {
	ID           int64          `json:"id"`
	ErrorMessage string         `json:"error_message"`
	FieldName    sql.NullString `json:"field_name"`
}

func (q *Queries) UpdateProcessingError(ctx context.Context, arg UpdateProcessingErrorParams) (ProcessingError, error) {
	row := q.db.QueryRowContext(ctx, updateProcessingError, arg.ID, arg.ErrorMessage, arg.FieldName)
	var i ProcessingError
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.LineNumber,
		&i.RawLine,
		&i.ErrorMessage,
		&i.FieldName,
		&i.CreatedAt,
	)
	return i, err
}
