// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: file.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createFile = `-- name: CreateFile :one
INSERT INTO files (
    filename, 
    file_hash, 
    status
) VALUES (
    $1, $2, $3
) RETURNING id, filename, file_hash, status, rows_processed, rows_failed, error_message, created_at, updated_at
`

type CreateFileParams struct {
	Filename string         `json:"filename"`
	FileHash string         `json:"file_hash"`
	Status   sql.NullString `json:"status"`
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.db.QueryRowContext(ctx, createFile, arg.Filename, arg.FileHash, arg.Status)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.FileHash,
		&i.Status,
		&i.RowsProcessed,
		&i.RowsFailed,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFile = `-- name: DeleteFile :exec
DELETE FROM files
WHERE id = $1
`

func (q *Queries) DeleteFile(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteFile, id)
	return err
}

const deleteOldFiles = `-- name: DeleteOldFiles :exec
DELETE FROM files
WHERE created_at < CURRENT_TIMESTAMP - interval '30 days'
AND status = $1
`

func (q *Queries) DeleteOldFiles(ctx context.Context, status sql.NullString) error {
	_, err := q.db.ExecContext(ctx, deleteOldFiles, status)
	return err
}

const getFileByFilename = `-- name: GetFileByFilename :one
SELECT id, filename, file_hash, status, rows_processed, rows_failed, error_message, created_at, updated_at FROM files
WHERE filename = $1 LIMIT 1
`

func (q *Queries) GetFileByFilename(ctx context.Context, filename string) (File, error) {
	row := q.db.QueryRowContext(ctx, getFileByFilename, filename)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.FileHash,
		&i.Status,
		&i.RowsProcessed,
		&i.RowsFailed,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFileByID = `-- name: GetFileByID :one
SELECT id, filename, file_hash, status, rows_processed, rows_failed, error_message, created_at, updated_at FROM files
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetFileByID(ctx context.Context, id int64) (File, error) {
	row := q.db.QueryRowContext(ctx, getFileByID, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.FileHash,
		&i.Status,
		&i.RowsProcessed,
		&i.RowsFailed,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listFiles = `-- name: ListFiles :many
SELECT id, filename, file_hash, status, rows_processed, rows_failed, error_message, created_at, updated_at FROM files
ORDER BY created_at DESC
LIMIT $1
OFFSET $2
`

type ListFilesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListFiles(ctx context.Context, arg ListFilesParams) ([]File, error) {
	rows, err := q.db.QueryContext(ctx, listFiles, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.FileHash,
			&i.Status,
			&i.RowsProcessed,
			&i.RowsFailed,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilesByDateRange = `-- name: ListFilesByDateRange :many
SELECT id, filename, file_hash, status, rows_processed, rows_failed, error_message, created_at, updated_at FROM files
WHERE created_at BETWEEN $1 AND $2
ORDER BY created_at DESC
`

type ListFilesByDateRangeParams struct {
	CreatedAt   sql.NullTime `json:"created_at"`
	CreatedAt_2 sql.NullTime `json:"created_at_2"`
}

func (q *Queries) ListFilesByDateRange(ctx context.Context, arg ListFilesByDateRangeParams) ([]File, error) {
	rows, err := q.db.QueryContext(ctx, listFilesByDateRange, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.FileHash,
			&i.Status,
			&i.RowsProcessed,
			&i.RowsFailed,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilesByStatus = `-- name: ListFilesByStatus :many
SELECT id, filename, file_hash, status, rows_processed, rows_failed, error_message, created_at, updated_at FROM files
WHERE status = $1
ORDER BY created_at DESC
`

func (q *Queries) ListFilesByStatus(ctx context.Context, status sql.NullString) ([]File, error) {
	rows, err := q.db.QueryContext(ctx, listFilesByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.FileHash,
			&i.Status,
			&i.RowsProcessed,
			&i.RowsFailed,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFileProgress = `-- name: UpdateFileProgress :one
UPDATE files
SET
    rows_processed = $2,
    rows_failed = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, filename, file_hash, status, rows_processed, rows_failed, error_message, created_at, updated_at
`

type UpdateFileProgressParams struct {
	ID            int64         `json:"id"`
	RowsProcessed sql.NullInt32 `json:"rows_processed"`
	RowsFailed    sql.NullInt32 `json:"rows_failed"`
}

func (q *Queries) UpdateFileProgress(ctx context.Context, arg UpdateFileProgressParams) (File, error) {
	row := q.db.QueryRowContext(ctx, updateFileProgress, arg.ID, arg.RowsProcessed, arg.RowsFailed)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.FileHash,
		&i.Status,
		&i.RowsProcessed,
		&i.RowsFailed,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateFileStatus = `-- name: UpdateFileStatus :one
UPDATE files
SET
    status = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, filename, file_hash, status, rows_processed, rows_failed, error_message, created_at, updated_at
`

type UpdateFileStatusParams struct {
	ID     int64          `json:"id"`
	Status sql.NullString `json:"status"`
}

func (q *Queries) UpdateFileStatus(ctx context.Context, arg UpdateFileStatusParams) (File, error) {
	row := q.db.QueryRowContext(ctx, updateFileStatus, arg.ID, arg.Status)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.FileHash,
		&i.Status,
		&i.RowsProcessed,
		&i.RowsFailed,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateFileWithError = `-- name: UpdateFileWithError :one
UPDATE files
SET
    status = $2,
    error_message = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, filename, file_hash, status, rows_processed, rows_failed, error_message, created_at, updated_at
`

type UpdateFileWithErrorParams struct {
	ID           int64          `json:"id"`
	Status       sql.NullString `json:"status"`
	ErrorMessage sql.NullString `json:"error_message"`
}

func (q *Queries) UpdateFileWithError(ctx context.Context, arg UpdateFileWithErrorParams) (File, error) {
	row := q.db.QueryRowContext(ctx, updateFileWithError, arg.ID, arg.Status, arg.ErrorMessage)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.FileHash,
		&i.Status,
		&i.RowsProcessed,
		&i.RowsFailed,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
