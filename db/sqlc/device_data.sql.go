// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: device_data.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const bulkInsertDeviceData = `-- name: BulkInsertDeviceData :exec
INSERT INTO device_data (
    file_id,
    unit_guid,
    mqtt,
    invid,
    msg_id,
    text,
    context,
    class,
    level,
    area,
    addr,
    block,
    type,
    bit,
    invert_bit,
    line_number
) VALUES 
    ( $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16 ),
    ( $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32 )
RETURNING id, file_id, unit_guid, mqtt, invid, msg_id, text, context, class, level, area, addr, block, type, bit, invert_bit, line_number, created_at
`

type BulkInsertDeviceDataParams struct {
	FileID       int64          `json:"file_id"`
	UnitGuid     uuid.UUID      `json:"unit_guid"`
	Mqtt         sql.NullString `json:"mqtt"`
	Invid        sql.NullString `json:"invid"`
	MsgID        sql.NullString `json:"msg_id"`
	Text         sql.NullString `json:"text"`
	Context      sql.NullString `json:"context"`
	Class        sql.NullString `json:"class"`
	Level        sql.NullInt32  `json:"level"`
	Area         sql.NullString `json:"area"`
	Addr         sql.NullString `json:"addr"`
	Block        sql.NullString `json:"block"`
	Type         sql.NullString `json:"type"`
	Bit          sql.NullInt32  `json:"bit"`
	InvertBit    sql.NullBool   `json:"invert_bit"`
	LineNumber   int32          `json:"line_number"`
	FileID_2     int64          `json:"file_id_2"`
	UnitGuid_2   uuid.UUID      `json:"unit_guid_2"`
	Mqtt_2       sql.NullString `json:"mqtt_2"`
	Invid_2      sql.NullString `json:"invid_2"`
	MsgID_2      sql.NullString `json:"msg_id_2"`
	Text_2       sql.NullString `json:"text_2"`
	Context_2    sql.NullString `json:"context_2"`
	Class_2      sql.NullString `json:"class_2"`
	Level_2      sql.NullInt32  `json:"level_2"`
	Area_2       sql.NullString `json:"area_2"`
	Addr_2       sql.NullString `json:"addr_2"`
	Block_2      sql.NullString `json:"block_2"`
	Type_2       sql.NullString `json:"type_2"`
	Bit_2        sql.NullInt32  `json:"bit_2"`
	InvertBit_2  sql.NullBool   `json:"invert_bit_2"`
	LineNumber_2 int32          `json:"line_number_2"`
}

func (q *Queries) BulkInsertDeviceData(ctx context.Context, arg BulkInsertDeviceDataParams) error {
	_, err := q.db.ExecContext(ctx, bulkInsertDeviceData,
		arg.FileID,
		arg.UnitGuid,
		arg.Mqtt,
		arg.Invid,
		arg.MsgID,
		arg.Text,
		arg.Context,
		arg.Class,
		arg.Level,
		arg.Area,
		arg.Addr,
		arg.Block,
		arg.Type,
		arg.Bit,
		arg.InvertBit,
		arg.LineNumber,
		arg.FileID_2,
		arg.UnitGuid_2,
		arg.Mqtt_2,
		arg.Invid_2,
		arg.MsgID_2,
		arg.Text_2,
		arg.Context_2,
		arg.Class_2,
		arg.Level_2,
		arg.Area_2,
		arg.Addr_2,
		arg.Block_2,
		arg.Type_2,
		arg.Bit_2,
		arg.InvertBit_2,
		arg.LineNumber_2,
	)
	return err
}

const createDeviceData = `-- name: CreateDeviceData :one
INSERT INTO device_data (
    file_id,
    unit_guid,
    mqtt,
    invid,
    msg_id,
    text,
    context,
    class,
    level,
    area,
    addr,
    block,
    type,
    bit,
    invert_bit,
    line_number
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
) RETURNING id, file_id, unit_guid, mqtt, invid, msg_id, text, context, class, level, area, addr, block, type, bit, invert_bit, line_number, created_at
`

type CreateDeviceDataParams struct {
	FileID     int64          `json:"file_id"`
	UnitGuid   uuid.UUID      `json:"unit_guid"`
	Mqtt       sql.NullString `json:"mqtt"`
	Invid      sql.NullString `json:"invid"`
	MsgID      sql.NullString `json:"msg_id"`
	Text       sql.NullString `json:"text"`
	Context    sql.NullString `json:"context"`
	Class      sql.NullString `json:"class"`
	Level      sql.NullInt32  `json:"level"`
	Area       sql.NullString `json:"area"`
	Addr       sql.NullString `json:"addr"`
	Block      sql.NullString `json:"block"`
	Type       sql.NullString `json:"type"`
	Bit        sql.NullInt32  `json:"bit"`
	InvertBit  sql.NullBool   `json:"invert_bit"`
	LineNumber int32          `json:"line_number"`
}

func (q *Queries) CreateDeviceData(ctx context.Context, arg CreateDeviceDataParams) (DeviceDatum, error) {
	row := q.db.QueryRowContext(ctx, createDeviceData,
		arg.FileID,
		arg.UnitGuid,
		arg.Mqtt,
		arg.Invid,
		arg.MsgID,
		arg.Text,
		arg.Context,
		arg.Class,
		arg.Level,
		arg.Area,
		arg.Addr,
		arg.Block,
		arg.Type,
		arg.Bit,
		arg.InvertBit,
		arg.LineNumber,
	)
	var i DeviceDatum
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.UnitGuid,
		&i.Mqtt,
		&i.Invid,
		&i.MsgID,
		&i.Text,
		&i.Context,
		&i.Class,
		&i.Level,
		&i.Area,
		&i.Addr,
		&i.Block,
		&i.Type,
		&i.Bit,
		&i.InvertBit,
		&i.LineNumber,
		&i.CreatedAt,
	)
	return i, err
}

const deleteDeviceData = `-- name: DeleteDeviceData :exec
DELETE FROM device_data
WHERE id = $1
`

func (q *Queries) DeleteDeviceData(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteDeviceData, id)
	return err
}

const deleteDeviceDataByFileID = `-- name: DeleteDeviceDataByFileID :exec
DELETE FROM device_data
WHERE file_id = $1
`

func (q *Queries) DeleteDeviceDataByFileID(ctx context.Context, fileID int64) error {
	_, err := q.db.ExecContext(ctx, deleteDeviceDataByFileID, fileID)
	return err
}

const getDeviceDataByFileID = `-- name: GetDeviceDataByFileID :many
SELECT id, file_id, unit_guid, mqtt, invid, msg_id, text, context, class, level, area, addr, block, type, bit, invert_bit, line_number, created_at FROM device_data
WHERE file_id = $1
ORDER BY line_number
`

func (q *Queries) GetDeviceDataByFileID(ctx context.Context, fileID int64) ([]DeviceDatum, error) {
	rows, err := q.db.QueryContext(ctx, getDeviceDataByFileID, fileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeviceDatum
	for rows.Next() {
		var i DeviceDatum
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.UnitGuid,
			&i.Mqtt,
			&i.Invid,
			&i.MsgID,
			&i.Text,
			&i.Context,
			&i.Class,
			&i.Level,
			&i.Area,
			&i.Addr,
			&i.Block,
			&i.Type,
			&i.Bit,
			&i.InvertBit,
			&i.LineNumber,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeviceDataByID = `-- name: GetDeviceDataByID :one
SELECT id, file_id, unit_guid, mqtt, invid, msg_id, text, context, class, level, area, addr, block, type, bit, invert_bit, line_number, created_at FROM device_data
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetDeviceDataByID(ctx context.Context, id int64) (DeviceDatum, error) {
	row := q.db.QueryRowContext(ctx, getDeviceDataByID, id)
	var i DeviceDatum
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.UnitGuid,
		&i.Mqtt,
		&i.Invid,
		&i.MsgID,
		&i.Text,
		&i.Context,
		&i.Class,
		&i.Level,
		&i.Area,
		&i.Addr,
		&i.Block,
		&i.Type,
		&i.Bit,
		&i.InvertBit,
		&i.LineNumber,
		&i.CreatedAt,
	)
	return i, err
}

const getDeviceStatistics = `-- name: GetDeviceStatistics :one
SELECT
    COUNT(*) as total_records,
    COUNT(DISTINCT unit_guid) as unique_devices,
    COUNT(DISTINCT class) as unique_classes,
    MIN(created_at) as first_record,
    MAX(created_at) as last_record
FROM device_data
WHERE file_id = $1
`

type GetDeviceStatisticsRow struct {
	TotalRecords  int64       `json:"total_records"`
	UniqueDevices int64       `json:"unique_devices"`
	UniqueClasses int64       `json:"unique_classes"`
	FirstRecord   interface{} `json:"first_record"`
	LastRecord    interface{} `json:"last_record"`
}

func (q *Queries) GetDeviceStatistics(ctx context.Context, fileID int64) (GetDeviceStatisticsRow, error) {
	row := q.db.QueryRowContext(ctx, getDeviceStatistics, fileID)
	var i GetDeviceStatisticsRow
	err := row.Scan(
		&i.TotalRecords,
		&i.UniqueDevices,
		&i.UniqueClasses,
		&i.FirstRecord,
		&i.LastRecord,
	)
	return i, err
}

const listDeviceDataByClass = `-- name: ListDeviceDataByClass :many
SELECT id, file_id, unit_guid, mqtt, invid, msg_id, text, context, class, level, area, addr, block, type, bit, invert_bit, line_number, created_at FROM device_data
WHERE class = $1 AND file_id = $2
ORDER BY line_number
`

type ListDeviceDataByClassParams struct {
	Class  sql.NullString `json:"class"`
	FileID int64          `json:"file_id"`
}

func (q *Queries) ListDeviceDataByClass(ctx context.Context, arg ListDeviceDataByClassParams) ([]DeviceDatum, error) {
	rows, err := q.db.QueryContext(ctx, listDeviceDataByClass, arg.Class, arg.FileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeviceDatum
	for rows.Next() {
		var i DeviceDatum
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.UnitGuid,
			&i.Mqtt,
			&i.Invid,
			&i.MsgID,
			&i.Text,
			&i.Context,
			&i.Class,
			&i.Level,
			&i.Area,
			&i.Addr,
			&i.Block,
			&i.Type,
			&i.Bit,
			&i.InvertBit,
			&i.LineNumber,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeviceDataByUnit = `-- name: ListDeviceDataByUnit :many
SELECT id, file_id, unit_guid, mqtt, invid, msg_id, text, context, class, level, area, addr, block, type, bit, invert_bit, line_number, created_at FROM device_data
WHERE unit_guid = $1
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type ListDeviceDataByUnitParams struct {
	UnitGuid uuid.UUID `json:"unit_guid"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

func (q *Queries) ListDeviceDataByUnit(ctx context.Context, arg ListDeviceDataByUnitParams) ([]DeviceDatum, error) {
	rows, err := q.db.QueryContext(ctx, listDeviceDataByUnit, arg.UnitGuid, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeviceDatum
	for rows.Next() {
		var i DeviceDatum
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.UnitGuid,
			&i.Mqtt,
			&i.Invid,
			&i.MsgID,
			&i.Text,
			&i.Context,
			&i.Class,
			&i.Level,
			&i.Area,
			&i.Addr,
			&i.Block,
			&i.Type,
			&i.Bit,
			&i.InvertBit,
			&i.LineNumber,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchDeviceDataText = `-- name: SearchDeviceDataText :many
SELECT id, file_id, unit_guid, mqtt, invid, msg_id, text, context, class, level, area, addr, block, type, bit, invert_bit, line_number, created_at FROM device_data
WHERE text ILIKE '%' || $1 || '%'
AND file_id = $2
ORDER BY line_number
`

type SearchDeviceDataTextParams struct {
	Column1 sql.NullString `json:"column_1"`
	FileID  int64          `json:"file_id"`
}

func (q *Queries) SearchDeviceDataText(ctx context.Context, arg SearchDeviceDataTextParams) ([]DeviceDatum, error) {
	rows, err := q.db.QueryContext(ctx, searchDeviceDataText, arg.Column1, arg.FileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeviceDatum
	for rows.Next() {
		var i DeviceDatum
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.UnitGuid,
			&i.Mqtt,
			&i.Invid,
			&i.MsgID,
			&i.Text,
			&i.Context,
			&i.Class,
			&i.Level,
			&i.Area,
			&i.Addr,
			&i.Block,
			&i.Type,
			&i.Bit,
			&i.InvertBit,
			&i.LineNumber,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDeviceData = `-- name: UpdateDeviceData :one
UPDATE device_data
SET
    text = $2,
    level = $3,
    class = $4
WHERE id = $1
RETURNING id, file_id, unit_guid, mqtt, invid, msg_id, text, context, class, level, area, addr, block, type, bit, invert_bit, line_number, created_at
`

type UpdateDeviceDataParams struct {
	ID    int64          `json:"id"`
	Text  sql.NullString `json:"text"`
	Level sql.NullInt32  `json:"level"`
	Class sql.NullString `json:"class"`
}

func (q *Queries) UpdateDeviceData(ctx context.Context, arg UpdateDeviceDataParams) (DeviceDatum, error) {
	row := q.db.QueryRowContext(ctx, updateDeviceData,
		arg.ID,
		arg.Text,
		arg.Level,
		arg.Class,
	)
	var i DeviceDatum
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.UnitGuid,
		&i.Mqtt,
		&i.Invid,
		&i.MsgID,
		&i.Text,
		&i.Context,
		&i.Class,
		&i.Level,
		&i.Area,
		&i.Addr,
		&i.Block,
		&i.Type,
		&i.Bit,
		&i.InvertBit,
		&i.LineNumber,
		&i.CreatedAt,
	)
	return i, err
}
